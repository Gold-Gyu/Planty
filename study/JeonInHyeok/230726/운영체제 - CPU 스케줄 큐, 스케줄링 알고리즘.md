## 스케줄링 큐

- 우선순위가 정해진 프로세스들은 **스케줄링 큐**에 들어가 자신의 차례를 기다리게 됨.
- 반드시 선입선출인 것은 아니고, 
**우선순위와 스케줄링 알고리즘에 따라 다음 차례의 프로세스가 먼저 나올 수도 있음.**

### 스케줄링 큐의 종류

- **준비큐**
    - CPU를 이용하고 싶은 준비 상태의 프로세스들이 들어가는 큐
- **대기큐**
    - 입출력 장치를 이용하고 싶은 대기 상태의 프로세스들이 들어가는 큐
    - 입출력 장치별로 대기큐가 존재.
        - 입출력이 완료되어 인터럽트가 발생하면, 각 대기큐에서 작업이 완료된 PCB를 찾고, 
        PCB를 준비상태로 변경하여 대기큐에서 제거.
        
        

### 스케줄링 큐와 보는 프로세스 상태 다이어그램


- **생성 상태**
    - PCB 생성
- **준비 상태**
    - 자원 할당 대기
    - 준비 큐에 차례차례 들어감
- **실행 상태**
    - 우선순위와 스케줄링 알고리즘에 따라 **먼저 나온 프로세스가 실행**됨.
    - 입출력 요청 시, **대기상태가 되어 대기큐**에 들어감.
    - 입출력 완료 시, 대기큐에서 우선순위와 스케줄링 알고리즘에 따라 
    **먼저 나온 프로세스가 준비상태가 되어 준비큐**에 들어감.
    - 할당 받은 시간이 모두 끝나서 타이머 인터럽트 발생 시, 
    **준비상태가 되어 준비큐**에 들어감.
- **종료 상태**
    - **프로세스의 작업이 모두 완료되면 종료상태**가 됨.

## 선점형과 비선점형 스케줄링

- 스케줄링 방식은 크게 두 가지로 나뉨.

### 선점형 스케줄링

**→ 운영체제가 프로세스로부터 자원을 강제로 빼앗아서, 다른 프로세스에게 할당할 수 있는 스케줄링 방식**

- 위에서 본 예시들이 바로 선점형 스케줄링.
    - 타이머 인터럽트 발생 시, 운영체제가 해당 프로세스로부터 CPU 자원을 빼앗아서 
    다음 프로세스에 할당하는 방식.

### 비선점형 스케줄링

→ 하나의 프로세스가 자원을 사용하고 있다면, 그 프로세스가 해당 프로세스가 종료되거나 스스로 대기상태에 접어들기 전까지는 끼어들 수 없는 스케줄링 방식

### 장/단점

- **선점형 스케줄링**
    - 장점 : 한 프로세스의 **자원 독점을 막을 수 있음.**
    - 단점 : 문맥 교환 과정에서 **오버헤드 발생 가능성 ↑**
- **비선점형 스케줄링**
    - 장점 : 문맥 교환의 횟수가 적어서, **오버헤드가 적음**
    - 단점 : 모든 프로세스가 **골고루 자원을 사용할 수 없음. (계속 기다려야 해서)**

# 11-2. CPU 스케줄링 알고리즘

## 스케줄링 알고리즘의 종류

### 선입 선처리 스케줄링 (FCFS 스케줄링)

**→ 단순히 큐에 삽입된 순서대로 프로세스를 처리하는 방식**

- 비선점형 스케줄링 방식
- **CPU를 오래 사용하는 프로세스가 먼저 도착**하면 **다른 프로세스는 무작정 기다린다는 단점**이 있음. → **호위 효과**

### 최단 작업 우선 스케줄링 (SJF 스케줄링)

**→ 준비 큐에서 기다리는 프로세스 중, CPU 이용 시간이 가장 짧은 프로세스부터 실행하는 방식**

- 비선점형 스케줄링 방식 (선점형으로 분류될 수도 있음)

### 라운드 로빈 스케줄링

**→ 정해진 타임 슬라이스만큼의 시간 동안 돌아가며 CPU를 이용하는 방식.**

- 선점형 스케줄링 방식.
- 선입 선처리 스케줄링 + 타임 슬라이스(각 프로세스가 CPU를 사용할 수 있는 정해진 시간)
- 큐에 삽입된 순서대로 CPU를 이용하되, **정해진 시간만큼만 이용**하고,
프로세스 완료가 되지 않았다면 다시 큐의 맨 뒤로 삽입됨. (이때 문맥교환 발생!)
- **타임슬라이스의 크기가 중요함.**
    - 타임슬라이스가 지나치게 크면 선입 선처리 스케줄링과 다를바가 없음. (호위효과 발생)
    - 타임슬라이스가 지나치게 작으면, 문맥교환이 자주 발생해서 오버헤드가 커짐.

### 최소 잔여 시간 우선 스케줄링 (SRT 스케줄링)

**→ 정해진 타임슬라이스만큼 CPU를 사용하되, 
다음 프로세스는 남아있는 작업 시간이 가장 적은 프로세스가 선택되는 방식**

- 선점형 스케줄링 방식
- 최단 작업 우선 스케줄링 + 라운드 로빈

### 우선순위 스케줄링

→ **프로세스들에 우선순위를 부여하고, 가장 높은 우선순위를 가진 프로세스부터 실행하는 방식**

- 앞서 언급한, 최단 작업 우선 & 최소 잔여 시간 우선 방식은 
**넓은 범위에서 우선순위 스케줄링의 일종.**
- **기아 현상 발생 우려**
    - 우선순위가 낮은 프로세스는 준비큐에 먼저 삽입되어도 실행이 밀려 계속 연기될 수 있음.
    - 기아 현상을 해결하기 위한 **에이징**
        - 오래 대기한 프로세스의 우선순위를 점차 높이는 방식. 나이를 먹듯이.

### 다단계 큐 스케줄링

→ 우선 순위 별로 준비 큐를 여러 개 사용하고, **우선순위가 높은 큐의 프로세스를 우선 처리**하는 방식.


- 우선순위 스케줄링의 개선판
- 장점
    - 프로세스 유형별로 우선순위를 구분하여 실행하는 것이 편리해짐.
    - 큐 별로 타임 슬라이스를 여러 개 지정할 수 있고, 큐마다 다른 스케줄링 알고리즘 사용 가능.
- 단점
    - 프로세스들이 큐 사이를 이동할 수 없음. → 결국 기아 현상 발생.

### 다단계 피드백 큐 스케줄링

**→ 다단계 큐 스케줄링 + 프로세스들이 큐 사이를 이동할 수 있는 방식**

- 다단계 큐 스케줄링의 개선판
- 새로 준비 상태가 된 프로세스가 있다면 **우선 순위가 가장 높은 우선순위 큐에 삽입**되고,
일정 시간(타임 슬라이스) 동안 실행됨.
    - 해당 큐에서 프로세스가 종료되지 않는다면, **다음 우선순위 큐에 삽입되어 실행**됨.
    - 반복… (점차 우선순위가 낮아짐) → 공정해짐.
- 마찬가지로, **에이징 기법 적용 가능.**
    - 낮은 우선순위 큐에 계속 머무른다면, 점차 위로 이동시킴
- **즉, CPU 이용 시간이 길면 낮은 우선순위로 점차 이동시키고,
낮은 우선순위 큐에서 너무 오래 기다리면 높은 우선순위 큐로 이동시키는 알고리즘.**